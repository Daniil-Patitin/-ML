#Большой код с аппроксимацией функции от двух переменных и дальнейшее ее дифференцирование и интегрирование, а так же решение сопутсвующей СЛАУ тремя методами  
# -*- coding: utf-8 -*-
"""course_design.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lTtgKWwXBuEzdnHfcVFgnpT5YklLbUt8
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd
import math

# Выбор решения СЛАУ:

system_solution = 1 # 0 - решение с помощью встроенной функции 
                    # 1 - решение методом LU-разложения

def function(x,y): 
  #return math.exp(x+y)
  #return  8*math.sin(x) + y
  #return (8*math.sin(x+y))*x*y 
  return x*x*y*y
  #return 1
def derivative_function_XX(x,y):
  #return 8*math.cos(x)
  #return (8*math.cos(x+y))*x*y +(8*math.sin(x+y))*y 
  return 2*x*y*y
def derivative_function_YY(x,y):
  #return 1
  #return 8*math.cos(x+y)*x*y +8*math.sin(x+y)*x
  return 2*x*x*y
#ввести диапозон:
domain_X = [-2,2]     #диапазон области по Х
domain_Y = [-2,2]     #диапазон области по У

#ввести степень полинома:
amount_domain_in_element_X = 2    #параметр, определяющий количество узлов в элементе по Х
amount_domain_in_element_Y = 2    #параметр, определяющий количество узлов в элементе по У

#ввести количество элементов в области:
domain_elemant_1X = 3             #параметр, определяющий количество элементов в области по X
domain_elemant_1Y = 2             #параметр, определяющий количество элементов в области по Y

amount_domain_X = domain_elemant_1X * amount_domain_in_element_X  
amount_domain_Y = domain_elemant_1Y * amount_domain_in_element_Y

delta_X = (domain_X[1]-domain_X[0])/amount_domain_X    #шаг по Х
delta_Y = (domain_Y[1]-domain_Y[0])/amount_domain_Y    #шаг по Y

amount_bases_point = (amount_domain_X+1) * (amount_domain_Y+1)

#каким способом задать точки в области:  
point_selection = 1 # 1 задается определенное количество точек в каждом элементе
                    # 2 задается рандомно на всей области
                    # 3 задается на подобласти 

#в случае 1 исключить какой-нибудь элемент?(в случае 2 и 3 не исключаем элементы):
exclusion = 0 # 1 если исключить и 0 если не исключать. В случае point_selection == 1
#какие области убрать:
exclusion_domain = [2] 
exclusion_domain = np.sort(exclusion_domain, -1)

# в случае point_selection == 3 выбираем подобласть для заполнения ее точками: 
under_domain_X = [-2,-1]
under_domain_Y = [-2,-1]
if point_selection == 3:
  amount_point = 40   #какое количество точек на одобласти задать
  x = np.array([random.uniform(under_domain_X[0], under_domain_X[1]) for i in range(amount_point)])   
  y = np.array([random.uniform(under_domain_Y[0], under_domain_Y[1]) for i in range(amount_point)])

#задаем точки рандоино на всей области 
if point_selection == 2: # задает рандомно amount_point точек на всей области 
  amount_point = 40
  x = np.array([random.uniform(domain_X[0], domain_X[1]) for i in range(amount_point)])   
  y = np.array([random.uniform(domain_Y[0], domain_Y[1]) for i in range(amount_point)])

#задаем в каждом эелементе рандомно какое-то количество точек
if point_selection == 1:
  amount_element_in_domain = domain_elemant_1X * domain_elemant_1Y              # на сколько элементов разбилась изначальная область 
  amount_point_1 = 18                                                           # указать сколько точек должно быть в каждом элементе 
  element_in_domain_X = 1                                                       # следим за элементом по строке (на каком элементе находимся) 
  element_in_domain_Y = 1                                                       # тоже самое по столбцу 
  step_amount_point_X = 0                                                       # шаг для заполнения массива по строкам рандомными точками 
  amount_step_X = 0                                                             # параметр для определения диапозона задания точек по строкам (Х)
  step_amount_point_Y = 0                                                       # шаг для заполнения массива по столбцам рандомными точками 
  amount_step_Y = 0                                                             # параметр для определения диапозона задания точек по столбцам (У)
  amount_point = amount_element_in_domain * amount_point_1                      # количество точек, которыми заполним всю исходную область 
  amount_point_X = amount_point_1
  amount_point_Y = amount_point_1
  x = []
  y = []
  coef = 0                                                                      # коэффициент, необходимый для изменения диапозона по строке 

  for kk in range(amount_element_in_domain):
    if element_in_domain_X < domain_elemant_1X + 1:
      x1 = np.array([random.uniform(domain_X[0] + ((delta_X * amount_step_X) * amount_domain_in_element_X), domain_X[0] +(delta_X * amount_domain_in_element_X * (amount_step_X+1))) for i in range(step_amount_point_X, amount_point_X)])
      element_in_domain_X = element_in_domain_X + 1  
      step_amount_point_X = step_amount_point_X + amount_point_1
      amount_point_X = amount_point_X + amount_point_1
      amount_step_X = amount_step_X + 1
    else:
      element_in_domain_X = 1
      amount_step_X = 0   
      x1 = np.array([random.uniform(domain_X[0] + delta_X * amount_step_X * amount_domain_in_element_X, domain_X[0] +(delta_X * amount_domain_in_element_X * (amount_step_X+1))) for i in range(step_amount_point_X, amount_point_X)])
      element_in_domain_X = element_in_domain_X + 1  
      step_amount_point_X = step_amount_point_X + amount_point_1
      amount_point_X = amount_point_X + amount_point_1
      amount_step_X = amount_step_X + 1
    x = np.append(x, x1)
    if element_in_domain_Y < domain_elemant_1X + 1:
      y1 = np.array([random.uniform(domain_Y[0] + delta_Y * coef * amount_domain_in_element_Y, domain_Y[0] +(delta_Y * amount_domain_in_element_Y * (coef+1))) for i in range(step_amount_point_Y, amount_point_Y)])
      element_in_domain_Y = element_in_domain_Y + 1  
      step_amount_point_Y = step_amount_point_Y + amount_point_1
      amount_point_Y = amount_point_Y + amount_point_1
      amount_step_Y = amount_step_Y + 1
    else:
      coef = coef + 1
      element_in_domain_Y = 1
      amount_step_Y = 0   
      y1 = np.array([random.uniform(domain_Y[0] + delta_Y * coef * amount_domain_in_element_Y, domain_Y[0] +(delta_Y * amount_domain_in_element_Y * (coef+1))) for i in range(step_amount_point_Y, amount_point_Y)])
      element_in_domain_Y = element_in_domain_Y + 1  
      step_amount_point_Y = step_amount_point_Y + amount_point_1
      amount_point_Y = amount_point_Y + amount_point_1
      amount_step_Y = amount_step_Y + 1 
    y = np.append(y, y1)
    jj = 1 
  
  if exclusion == 1:
    for j in range(len(exclusion_domain)):    
      x = np.delete(x, [i  for i in range(amount_point_1 * (exclusion_domain[j]-jj), amount_point_1 * (exclusion_domain[j] -jj)+ amount_point_1)])
      y = np.delete(y, [i  for i in range(amount_point_1 * (exclusion_domain[j]-jj), amount_point_1 * (exclusion_domain[j] - jj) + amount_point_1)])
      amount_point = len(x)
      jj = jj + 1


for i in range(amount_point):   
  random_point_1 = x[i]
  random_point_2 = y[i]
  plt.plot(random_point_1, random_point_2, 'ro', color = 'black', markersize = 2)
xy = x
yx = y
A_x = np.array([domain_X[0] + delta_X * ((i - 1) % (amount_domain_X + 1)) for i in range(1, (amount_domain_X + 1) * (amount_domain_Y + 1) + 1)])
A_y = np.array([domain_Y[0] + delta_Y * ((i - 1) // (amount_domain_X + 1)) for i in range(1, (amount_domain_X + 1) * (amount_domain_Y + 1) + 1)])
arr = np.zeros(((amount_domain_X + 1) * (amount_domain_Y + 1), 3))

for i in range(amount_bases_point):     
  arr[i, 0] = A_x[i]
  arr[i, 1] = A_y[i]
  arr[i, 2] = i 
  point_1 = A_x[i]
  point_2 = A_y[i]  
  plt.plot(point_1, point_2, 'ro', color = 'red', markersize = 4)

def base_function(i,x,y):
  I_x = (x-domain_X[0])/(delta_X * amount_domain_in_element_X)
  I_x = math.ceil(I_x)
  if I_x > (domain_X[1] - domain_X[0])/(delta_X * amount_domain_in_element_X):
    I_x = I_x - 1
  if I_x == 0:
    I_x = 1
  J_y = (y-domain_Y[0])/(delta_Y * amount_domain_in_element_Y)
  J_y = math.ceil(J_y)
  if J_y > (domain_Y[1] - domain_Y[0])/(delta_Y * amount_domain_in_element_Y):
    J_y = J_y - 1
  if J_y == 0:
    J_y = 1

  initial_point_element = (amount_domain_X+1) * (amount_domain_in_element_Y) * (J_y-1) + 1 + (I_x-1) * amount_domain_in_element_X-1
  l = initial_point_element
  ll = l
  S1,S2 = 0,0
  for k in range(amount_domain_in_element_Y+1):
      I1 = np.array([ll+kkk for kkk in range(amount_domain_in_element_X+1)])
      for k1 in range(amount_domain_in_element_X+1):
        if I1[k1] == i:
          S1 = 1
      ll = ll + amount_domain_X + 1       
  if (S1 == 0):
     return 0
  else:
     L1,L2 = 1,1
     for k2 in range(amount_domain_in_element_X+1):
       if arr[l+k2, 0] == arr[i, 0]:
         L1 = L1
       else:
         L1 = L1 * ((x-arr[l+k2, 0])/(arr[i, 0]-arr[l+k2, 0]))
     for k3 in range(amount_domain_in_element_Y+1):
       U = l+k3*(amount_domain_X+1)   
       if arr[U, 1] == arr[i, 1]:
         L2 = L2
       else:
         L2 = L2 * ((y-arr[U, 1])/(arr[i, 1]-arr[U, 1]))
     return L1*L2
 
  
def matrix_A(i,j):          
  res = 0
  for k in range(amount_point):
    res = res + base_function(i,x[k],y[k]) * base_function(j,x[k],y[k])
  return res

def vector_B(i):
  res = 0
  for k in range(amount_point):
    res = res + function(x[k],y[k]) * base_function(i,x[k],y[k])
  return res

A = np.array([matrix_A(i%amount_bases_point ,i//(amount_bases_point)) for i in range((amount_bases_point)**2)])
 
A = A.reshape((amount_bases_point), -1)

b = [vector_B(i) for i in range(amount_bases_point)]
cheky = 0
for i in range(amount_bases_point):
  for j in range(amount_bases_point):
    if A[i,j] == 0:
      cheky=cheky + 1
  if cheky==amount_bases_point:
    A[i,i] = 1
    b[i] = 1
  cheky = 0
for system_solution in range(2):

  if system_solution == 0: 
    C = np.linalg.solve(A,b)

  if system_solution == 1:

    l = np.array([i*0 for i in range(len(A)**2)], float)
    u = np.array([i*0 for i in range(len(A)**2)], float)

    l = l.reshape(amount_bases_point,-1)
    u = u.reshape(amount_bases_point,-1)


    for j in range(amount_bases_point):
      u[0,j] = A[0,j]
      per = A[j,0]/u[0,0]
      l[j,0] = per
    
    for i in range(1,amount_bases_point):
      for j in range(1,amount_bases_point):
        resU=0
        if (i <= j):
          for k in range(i+1):
            resU = resU + l[i,k]*u[k,j]
          u[i,j] = A[i,j] - resU 
        resL = 0
        if (i <= j):
          for k in range(i+1):
            if k == i:
              k=k
            else:
              resL = resL + l[j,k]*u[k,i]
          if (u[i,i] == 0):
            l[j,i] = 1
          else :
            l[j,i] = ( 1/u[i,i] ) * ( A[j,i] - resL )
            if (i==j) and (l[i,i]==0):
              l[i,i] = 1

    resBY, resYX = 0, 0
    y = np.array([0*i for i in range(amount_bases_point)], float)
    y[0] = b[0]/l[0,0]
    for i in range(1,amount_bases_point):
      for j in range(i):
        resBY = resBY + y[j] * l[i,j]
      y[i] = (b[i] - resBY) / l[i,i]
      resBY = 0

    x = np.array([0*i for i in range(amount_bases_point)], float)
    x[amount_bases_point-1] = y[amount_bases_point-1] / u[amount_bases_point-1,amount_bases_point-1]

    for i in range(1,amount_bases_point):
      for j in range(i):
        resYX = resYX + u[amount_bases_point-1-i, amount_bases_point-1-j] * x[amount_bases_point-1-j]
      x[amount_bases_point-1-i] = (y[amount_bases_point-1-i] - resYX) / u[amount_bases_point-1-i, amount_bases_point-1-i]
      resYX = 0
summ = 0
for z in range(amount_bases_point):
  summ = summ + abs( ( C[z] - x[z] ) )
print('ПОГРЕШНОСТЬ В LU-РАЗЛОЖЕНИИ:', summ)
summ= 0 


x = np.array([0*i for i in range(amount_bases_point)], float)
g = np.array([0*i for i in range(amount_bases_point)], float)
g = b - np.dot(x,A)
p = np.array([0*i for i in range(amount_bases_point)], float)
p = g


summ = 0
for i in range(len(g)): 
  summ = summ + g[i]**2
g_k = summ**0.5
summ = 0
for i in range(len(b)): 
  summ = summ + b[i]**2
B = summ**0.5
summ = 0
while (abs(g_k / B) > 1e-8):
  
  alfa = (np.dot(g,g)) / np.dot((np.dot(p,A)),p)
  
  x = x + alfa * p
  
  denominator = np.dot(g,g)
  g = g - alfa * (np.dot(p,A))
  
  betta = (np.dot(g,g)) / (denominator)
  
  p = g + betta * p
  
  for i in range(len(g)): 
    summ = summ + g[i]**2
  g_k = summ**0.5
  summ = 0
  

WW=0
for i in range(amount_bases_point):
  WW = WW + abs(C[i] - x[i])
  #print((C[i] - x[i]))
  
print('ПОГРЕШНОСТЬ ДЛЯ МЕТОДА СОПРЯЖЕННЫХ ГРАДИЕНТОВ:',WW)

#####################3
#A = np.array([1,0,1,0,1,1,1,1,6],float)
#A = A.reshape(3,-1)
#B = np.array([2,5,9],float)
D = np.diag(np.diag(A))
W=1.5
X = np.array([0*i for i in range(amount_bases_point)],float)
X_i = np.array([0*i for i in range(amount_bases_point)],float)
def func_1(A,X_i,i):
  sum_= 0
  for j in range(i):
    sum_ = sum_ + A[i,j] * X_i[j]
    #print('1111111',i,j,A[i,j], X_i[j])
  return sum_
#print('2222222',func_1(A,X,1))
def func_2(A,X,i):
  sum_ = 0
  for j in range(i+1,len(X)):
    sum_ = sum_ + A[i,j] * X[j]
    #print('параметры для второй функции',i,j,A[i,j], X[i])
  return sum_
norma = 1
norma1 =1
while norma> 1e-8:
  for i in range(len(X)):
    if i == 0:
      X_i[i] = ((D[i,i] * X[i]) * (1-W) + W * b[i] - W * func_2(A,X,i))/D[i,i]
      #print('нулевой элемент',i)
    if i == len(X)-1:
      X_i[i] = ( (D[i,i] * X[i]) * (1-W) + W * b[i] - W * func_1(A,X_i,i) ) / D[i,i]
      #print('2',i)
    if (i!=0) and (i!=len(X)-1):
      X_i[i] = ((D[i,i] * X[i]) * (1-W) + W * b[i] - W * func_2(A,X,i) - W * func_1(A,X_i,i)) / D[i,i]
      #print('3',i)
    #print('D:',D[i,i],'X[i]:',X[i], 'W*B_i:',W * B[i],'func_2:',  func_2(A,X,i),'func_1:', func_1(A,X_i,i),'X:', X,'X_i', X_i)
    #print('конец цикла')
  sum_1=0
  for i in range(len(X)):
    sum_1 = sum_1 + (X[i]-X_i[i])**2
    #print('норма',X[i],X_i[i])
    X[i] = X_i[i]
  #print('вывод Х',X_i,X)
  norma = sum_1**0.5
  sum_1=0
  norma1 =norma1+1
  #print('норма',norma)
print('РАССМОТРЕНИЕ МЕТОДА ВЕРХНИХ РЕЛАКСАЦИЙ:')
print('количество итераций:',norma1, ', норма разности:', norma)
C = np.linalg.solve(A,b)
#print('точное решение:',C)
summa = 0
for i in range(len(A)):
  summa = summa + abs(X[i] - C[i])
print('ПОГРЕШНОСТЬ:', summa)

##################################3

c = C






def approximate(x,y):
    res = 0
    for i in range(amount_bases_point):
        res += base_function(i,x,y)*c[i]
    return res

def deviation():
  res = 0
  for k1 in np.arange(domain_X[0], domain_X[1], 0.1):
        for k2 in np.arange(domain_Y[0], domain_Y[1], 0.1):
            res = res + (function(k1,k2) - approximate(k1,k2))**2
  return res



def loss():
  lossi = 0
  for i in range(amount_point):
    lossi = lossi + (function(x[i],y[i]) - approximate(x[i],y[i]))**2
  
  return lossi

def loss_abs():
  lossabs = 0
  for i in range(amount_point):
    lossabs = lossabs + abs((function(x[i],y[i]) - approximate(x[i],y[i])))
  return lossabs

def loss_anlim():
  lossanlim = []
  for i in range(amount_point):
    anlim = np.array(function(x[i],y[i]) - approximate(x[i],y[i]))
    lossanlim = np.append(lossanlim, anlim)
  max_element = max(lossanlim)
  return max_element

def relative_deviation():
    relative = 0
    for i in range(amount_point):
      if (approximate(x[i],y[i]) <= 1e-8 or function(x[i],y[i]) <= 1e-8):
        relative = relative + 0
      else:
        relative = relative + (abs(1 - (approximate(x[i],y[i])/function(x[i],y[i]))))
    relative = (relative * 100)/ amount_point
    return relative

def relative_deviation1():
    relative = 0
    relative1 = 0
    for i in range(amount_point):
      if (approximate(x[i],y[i]) <= 1e-8 or function(x[i],y[i]) <= 1e-8):
        relative = relative + 0
      else:
        relative = relative + ((function(x[i],y[i]) - (approximate(x[i],y[i])))**2)
      relative1 = relative1 + (function(x[i],y[i]))**2
    relative = relative**0.5
    relative1 = relative1**0.5
    relative2 = (relative/relative1)*100
    return relative2

def relative_deviation2():
  lossanlim = []
  for i in range(amount_point):
    anlim = np.array(function(x[i],y[i]))
    lossanlim = np.append(lossanlim, anlim)
  max_element1 = max(lossanlim)
  relative = loss_anlim()/(max_element1)
    
  return relative


import pylab
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import cm

# Commented out IPython magic to ensure Python compatibility.
step_grid_X = (domain_X[1] - domain_X[0])/amount_point
step_grid_Y = (domain_Y[1] - domain_Y[0])/amount_point

# %matplotlib inline

def grafic_deviation(): 
  fig = pylab.figure()
  axes = Axes3D(fig)
  step_grid_X = (domain_X[1] - domain_X[0])/amount_point
  step_grid_Y = (domain_Y[1] - domain_Y[0])/amount_point
  x = np.arange(domain_X[0], domain_X[1], step_grid_X)
  y = np.arange(domain_Y[0], domain_Y[1], step_grid_Y)

  x_print, y_print = np.meshgrid(x,y)
  z_print_function =(np.array([function(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1) 
  z_print_approximate = (np.array([approximate(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)
  print('график квадрата отклонения:')
  axes.plot_surface(x_print,y_print,(z_print_function - z_print_approximate)**2, cmap  = cm.jet,  ) # рисуем функцию ошибки

  pylab.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

def grafic_approximate():
  fig = pylab.figure()
  axes = Axes3D(fig)

  x = np.arange(domain_X[0], domain_X[1], step_grid_X)
  y = np.arange(domain_Y[0], domain_Y[1], step_grid_Y)

  x_print, y_print = np.meshgrid(x,y)
  z_print_app = (np.array([approximate(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)
  print('график апроксимации:')
  axes.plot_surface(x_print,y_print,( z_print_app), cmap  = cm.jet )
  pylab.show()

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

hh = 1e-8
def grafic_derivative_function_X():
  fig = pylab.figure()
  axes = Axes3D(fig)

  def derivative_function_X(x,y):
    yy = (function(x+hh,y) - function(x-hh,y))/(2*hh)
    return  yy
  z_print_der = (np.array([derivative_function_X(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1) 

  print('производная для исходной функции по Х:')
  axes.plot_surface(x_print,y_print,(z_print_der), cmap  = cm.jet)
  pylab.show()


def grafic_derivative_function_Y():
  fig = pylab.figure()
  axes = Axes3D(fig)

  def derivative_function_Y(x,y): 
    yy = (function(x,y+hh) - function(x,y-hh))/(2*hh)
    return  yy
  z_print_der = (np.array([derivative_function_Y(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1) 

  print('производная для исходной функции по У:')
  axes.plot_surface(x_print,y_print,(z_print_der), cmap  = cm.jet)
  pylab.show()


delta_for_X = 1e-4
delta_for_Y = 1e-4

def grafic_derivative_X():
  fig = pylab.figure()
  axes = Axes3D(fig)
  amount_point = 100
  step_grid_X = (domain_X[1] - domain_X[0])/amount_point
  step_grid_Y = (domain_Y[1] - domain_Y[0])/amount_point
  x = np.arange(domain_X[0], domain_X[1], step_grid_X)
  y = np.arange(domain_Y[0], domain_Y[1], step_grid_Y)

  x_print, y_print = np.meshgrid(x,y)
   
  def derivative_for_approximate_X(x,y):
    derivative = (approximate(x + delta_for_X, y) - approximate(x - delta_for_X, y))/(2 * (delta_for_X))
    return derivative
 
  z_print_derivative = (np.array([derivative_for_approximate_X(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)

  print('производная для апроксимации по Х:')
  axes.plot_surface(x_print, y_print, z_print_derivative, cmap  = cm.jet)
  pylab.show()
 
def relative_X():
  relative = 0
  for j in range(amount_bases_point):
    derivative = (approximate(arr[j,0] + delta_for_X, arr[j,1]) - approximate(arr[j,0] - delta_for_X, arr[j,1]))/(2 * (delta_for_X))
    yy = (function(arr[j,0]+hh,arr[j,1]) - function(arr[j,0]-hh,arr[j,1]))/(2*hh)
    if (abs(derivative) <=1e-8 or abs(yy) <=1e-8):
      relative = relative + 0
    else:
      relative = relative + 100*abs(1 - (derivative/yy))
  relative = relative/amount_bases_point
  return relative

def grafic_derivative_Y():
  fig = pylab.figure()
  axes = Axes3D(fig)
  amount_point = 100
  step_grid_X = (domain_X[1] - domain_X[0])/amount_point
  step_grid_Y = (domain_Y[1] - domain_Y[0])/amount_point
  x = np.arange(domain_X[0], domain_X[1], step_grid_X)
  y = np.arange(domain_Y[0], domain_Y[1], step_grid_Y)

  x_print, y_print = np.meshgrid(x,y)
  
  def derivative_for_approximate_Y(x,y):
    derivative = (approximate(x, y + delta_for_Y) - approximate(x, y - delta_for_Y))/(2 * (delta_for_Y))
    return derivative

  z_print_derivative = (np.array([derivative_for_approximate_Y(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)

  print('производная для апроксимации по У:')
  axes.plot_surface(x_print, y_print, z_print_derivative, cmap  = cm.jet)
  pylab.show()

def relative_Y(): 
  relative = 0
  for j in range(amount_bases_point):
    derivative = (approximate(arr[j,0], arr[j,1]+ delta_for_Y) - approximate(arr[j,0], arr[j,1] - delta_for_Y))/(2 * (delta_for_Y))
    yy = (function(arr[j,0],arr[j,1]+hh) - function(arr[j,0],arr[j,1]-hh))/(2*hh)
    if (abs(derivative) <=1e-10 or abs(yy) <=1e-10):
      relative = relative + 0
      
    else:
      relative = relative + 100*abs(1 - (derivative/yy))
  relative = relative/(amount_bases_point)
  return relative  

def derivative_approximate_number_two_X1(x,y):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,x + delta_for_X, y) - base_function(i,x - delta_for_X, y))/(delta_for_X * 2))*c[i]
    return res

def grafic_deviation_2_X():

  fig = pylab.figure()
  axes = Axes3D(fig)

  def derivative_approximate_number_two_X(x,y):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,x + delta_for_X, y) - base_function(i,x - delta_for_X, y))/(delta_for_X * 2))*c[i]
    return res

  z_print_derivative_number_two = (np.array([derivative_approximate_number_two_X(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1) 

  print('производная для апроксимации по Х:')
  axes.plot_surface(x_print,y_print,(z_print_derivative_number_two), cmap  = cm.jet)
  pylab.show()
  
def relative_X1():
  relative = 0
  for j in range(amount_bases_point):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,arr[j,0] + delta_for_X, arr[j,1]) - base_function(i,arr[j,0] - delta_for_X, arr[j,1]))/(delta_for_X * 2))*c[i]
    yy = (function(arr[j,0]+hh,arr[j,1]) - function(arr[j,0]-hh,arr[j,1]))/(2*hh)
    if (abs(res) <=1e-8 or abs(yy) <=1e-8):
      relative = relative + 0
    else:
      relative = relative + 100*abs(1 - (res/yy))
  relative = relative/((amount_domain_X + 1) * (amount_domain_Y + 1))
  return relative 

def relative_X2():
  relative = 0
  relative1 = 0
  for j in range(amount_bases_point):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,arr[j,0] + delta_for_X, arr[j,1]) - base_function(i,arr[j,0] - delta_for_X, arr[j,1]))/(delta_for_X * 2))*c[i]
    yy = (function(arr[j,0]+hh,arr[j,1]) - function(arr[j,0]-hh,arr[j,1]))/(2*hh)
    if (abs(res) <=1e-8 or abs(yy) <=1e-8):
      relative = relative + 0
    else:
      relative = relative + (yy - res)**2
    relative1 = relative1 + yy**2
  relative = relative**0.5
  relative1 = relative1**0.5
  relative2 = relative/relative1
  relative2 = 100 * relative2
  return relative2 

def relative_X3():
  lossanlim = []
  anlim1 = []
  
  for i in range(amount_point):
    anlim = np.array((derivative_function_XX(x[i],y[i]) - derivative_approximate_number_two_X1(x[i],y[i])))
    lossanlim = np.append(lossanlim, anlim)
    lim = np.array((derivative_function_XX(x[i],y[i])))
    anlim1 = np.append(anlim1, lim)
  max_element1 = max(lossanlim)
  max_der = max(anlim1)
  relative = 100*(max_element1/(max_der))
    
  return relative

def derivative_approximate_number_two_Y1(x,y):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,x, y + delta_for_Y) - base_function(i,x,y - delta_for_Y))/(2 * delta_for_Y))*c[i]
    return res

def grafic_deviation_2_Y():

  fig = pylab.figure()
  axes = Axes3D(fig)

  def derivative_approximate_number_two_Y(x,y):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,x, y + delta_for_Y) - base_function(i,x,y - delta_for_Y))/(2 * delta_for_Y))*c[i]
    return res
 
  z_print_derivative_number_two = (np.array([derivative_approximate_number_two_Y(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1) 

  print('производная для апроксимации по У:')
  axes.plot_surface(x_print,y_print,(z_print_derivative_number_two), cmap  = cm.jet)
  pylab.show()

def relative_Y1():
  relative = 0
  for j in range(amount_bases_point):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,arr[j,0], arr[j,1] + delta_for_Y) - base_function(i,arr[j,0], arr[j,1] - delta_for_Y))/(delta_for_Y * 2))*c[i]
    yy = (function(arr[j,0],arr[j,1]+hh) - function(arr[j,0],arr[j,1]-hh))/(2*hh)
    if (abs(res) <=1e-8 or abs(yy) <=1e-8):
      relative = relative + 0
    else:
      relative = relative + 100*abs(1 - (res/yy))
  relative = relative/(amount_bases_point)
  return relative

def relative_Y2():
  relative = 0
  relative1 = 0
  for j in range(amount_bases_point):
    res = 0
    for i in range(amount_bases_point):
      res += ((base_function(i,arr[j,0], arr[j,1] + delta_for_Y) - base_function(i,arr[j,0], arr[j,1] - delta_for_Y))/(delta_for_Y * 2))*c[i]
    yy = (function(arr[j,0],arr[j,1]+hh) - function(arr[j,0],arr[j,1]-hh))/(2*hh)
    if (abs(res) <=1e-8 or abs(yy) <=1e-8):
      relative = relative + 0
    else:
      relative = relative + (yy - res)**2
    relative1 = relative1 + yy**2
  relative = relative**0.5
  relative1 = relative1**0.5
  relative2 = relative/relative1
  relative2 = 100 * relative2
  return relative2


def relative_Y3():
  lossanlim = []
  anlim1 = []
  
  for i in range(amount_point):
    anlim = np.array((derivative_function_YY(x[i],y[i]) - derivative_approximate_number_two_Y1(x[i],y[i])))
    lossanlim = np.append(lossanlim, anlim)
    lim = np.array((derivative_function_YY(x[i],y[i])))
    anlim1 = np.append(anlim1, lim)
  max_element1 = max(lossanlim)
  max_der = max(anlim1)
  relative = 100*(max_element1/(max_der))
    
  return relative

 
dxx = []
dyy = []

A_X= np.array([domain_X[0] + delta_X * ((i - 1) // (amount_domain_Y + 1)) for i in range(1, (amount_domain_X + 1) * (amount_domain_Y + 1) + 1)])
A_Y = np.array([domain_Y[0] + delta_Y * ((i - 1) % (amount_domain_Y + 1)) for i in range(1, (amount_domain_X + 1) * (amount_domain_Y + 1) + 1)])



def dx(i):
  
  if (arr[i,0] == domain_X[0]):
    rrr = (approximate(arr[i,0]+delta_X, arr[i,1]) - approximate(arr[i,0],arr[i,1]))/delta_X
    return rrr
  if ((arr[i,0]+delta_X) <=domain_X[1] and arr[i,0] > domain_X[0]):
    rrr = (approximate(arr[i,0]+delta_X, arr[i,1]) - approximate(arr[i,0] - delta_X,arr[i,1]))/(2*delta_X)
    oo = (function(arr[i,0]+delta_X, arr[i,1]) - function(arr[i,0],arr[i,1]))/delta_X
    
    return rrr
  else:
    rr = (approximate(arr[i-1,0] + delta_X, arr[i-1,1]) - approximate(arr[i-1,0],arr[i-1,1]))/delta_X
    
    return rr

def dy(i):
  
  if A_Y[i] == domain_Y[0]:
    tt = (approximate(A_X[i], A_Y[i]+delta_Y) - approximate(A_X[i], A_Y[i]))/delta_Y 
  if  (A_Y[i]+delta_Y) <= domain_Y[1] and A_Y[i] > domain_Y[0]:
    tt = (approximate(A_X[i], A_Y[i]+delta_Y) - approximate(A_X[i], A_Y[i] - delta_Y))/(2*delta_Y)
      
    
  if A_Y[i] == domain_Y[1]:
    tt = (approximate(A_X[i-1], A_Y[i-1]+delta_Y) - approximate(A_X[i-1], A_Y[i-1]))/delta_Y
  return tt



h = 1e-5

def derivative_function_for_X(x,y):
  res = (function(x+h,y) - function(x,y))/h
  return res

def derivative_function_for_Y(x,y):
  res = (function(x,y+h) - function(x,y))/h
  return res

def new_matrix_A(i,j):          
  res = 0
  for k in range(amount_bases_point):
    res = res + base_function(i,arr[k,0],arr[k,1]) * base_function(j,arr[k,0],arr[k,1])
  return res


def new_vector_B_for_X(i):
  res = 0
  for k in range(amount_bases_point):
    res = res + dx(k) * base_function(i,arr[k,0],arr[k,1])
    #print( base_function(i,arr[k,0],arr[k,1]))
    #print(dx(k))
  return res

def new_vector_B_for_Y(i):
  res = 0
  for k in range(amount_bases_point):
    res = res + dy(k) * base_function(i,A_X[k],A_Y[k])
    
  return res



A = np.array([new_matrix_A(i%((amount_domain_X + 1) * (amount_domain_Y + 1)),i//((amount_domain_X + 1) * (amount_domain_Y + 1))) for i in range(((amount_domain_X + 1) * (amount_domain_Y + 1))**2)])
Ay = np.array([new_matrix_A(i//((amount_domain_X + 1) * (amount_domain_Y + 1)),i%((amount_domain_X + 1) * (amount_domain_Y + 1))) for i in range(((amount_domain_X + 1) * (amount_domain_Y + 1))**2)])
A = A.reshape(((amount_domain_X + 1) * (amount_domain_Y + 1)), -1)
Ay = Ay.reshape(((amount_domain_X + 1) * (amount_domain_Y + 1)), -1)
b_X = [new_vector_B_for_X(i) for i in range(((amount_domain_X + 1) * (amount_domain_Y + 1)))]
b_Y = [new_vector_B_for_Y(i) for i in range(((amount_domain_X + 1) * (amount_domain_Y + 1)))]
cheky = 0
for i in range(amount_bases_point):
  for j in range(amount_bases_point):
    if A[i,j] == 0:
      cheky=cheky + 1
  if cheky==amount_bases_point:
    A[i,i] = 1
    b_X[i] = 1
    b_Y[i] = 1
  cheky = 0
c_x = np.linalg.solve(A,b_X)
c_y = np.linalg.solve(Ay,b_Y)

def new_approximate_for_X(x,y):
    res = 0
    for i in range(amount_bases_point):
        res += base_function(i,x,y)*c_x[i]
    return res

def new_approximate_for_Y(x,y):
    res = 0
    for i in range(amount_bases_point):
        res += base_function(i,x,y)*c_y[i]
    return res

def new_deviation_for_X():
  res = 0
  for k1 in np.arange(domain_X[0], domain_X[1], 0.1):
        for k2 in np.arange(domain_Y[0], domain_Y[1], 0.1):
            res = res + (derivative_function_for_X(k1,k2) - new_approximate_for_X(k1,k2))**2
  return res


def new_deviation_for_Y():
  res = 0
  for k1 in np.arange(domain_X[0], domain_X[1], 0.1):
        for k2 in np.arange(domain_Y[0], domain_Y[1], 0.1):
            res = res + (derivative_function_for_Y(k1,k2) - new_approximate_for_Y(k1,k2))**2
  return res

def lossk_for_X():
  losska = 0
  for i in range(amount_bases_point):
    losska = losska + (derivative_function_for_X(arr[i,0],arr[i,1]) - new_approximate_for_X(arr[i,0], arr[i,1]))**2
  return losska


def lossk_for_Y():
  losska = 0
  for i in range(amount_bases_point):
    losska = losska + (derivative_function_for_Y(arr[i,0],arr[i,1]) - new_approximate_for_Y(arr[i,0], arr[i,1]))**2
  return losska

def loss_abs_deviation_X():
  lossabs = 0
  for i in range(amount_bases_point):
    lossabs = lossabs + abs((derivative_function_for_X(arr[i,0],arr[i,1]) - new_approximate_for_X(arr[i,0], arr[i,1])))
  return lossabs

def loss_abs_deviation_Y():
  lossabs = 0
  for i in range(amount_bases_point):
    lossabs = lossabs + abs((derivative_function_for_Y(arr[i,0],arr[i,1]) - new_approximate_for_Y(arr[i,0], arr[i,1])))
  return lossabs 

def relative_deviation_X():
    relative = 0
    for i in range(amount_bases_point):
      if (new_approximate_for_X(arr[i,0], arr[i,1]) <= 1e-8 or derivative_function_for_X(arr[i,0],arr[i,1]) <= 1e-8):
        relative = relative + 0
      else:
        relative = relative + (abs(1 - (new_approximate_for_X(arr[i,0], arr[i,1])/derivative_function_for_X(arr[i,0],arr[i,1]))))
    relative = (relative * 100)/ amount_point
    return relative

def relative_XX2():
  relative = 0
  relative1 = 0
  for j in range(amount_point):
    if (abs(new_approximate_for_X(x[j],y[j]) <=1e-8 or abs(derivative_function_XX(x[j],y[j])) <=1e-8)):
      relative = relative + 0
    else:
      relative = relative + (derivative_function_XX(x[j],y[j]) - new_approximate_for_X(x[j],y[j]))**2
    relative1 = relative1 + derivative_function_XX(x[j],y[j])**2
  relative = relative**0.5
  relative1 = relative1**0.5
  relative2 = relative/relative1
  relative2 = (100 * relative2)/amount_point
  return relative2 

def relative_XX3():
  lossanlim = []
  anlim1 = []
   
  for i in range(amount_point):
    anlim = np.array((derivative_function_XX(x[i],y[i]) - new_approximate_for_X(x[j],y[j])))
    lossanlim = np.append(lossanlim, anlim)
    lim = np.array((derivative_function_XX(x[i],y[i])))
    anlim1 = np.append(anlim1, lim)
  max_element1 = max(lossanlim)
  max_der = max(anlim1)
  relative = (100*(max_element1/(max_der)))/amount_point
     
  return relative

 
def relative_deviation_Y():
    relative = 0
    for i in range(amount_bases_point):
      if (new_approximate_for_Y(arr[i,0], arr[i,1]) <= 1e-8 or derivative_function_for_Y(arr[i,0],arr[i,1]) <= 1e-8):
        relative = relative + 0
      else:
        relative = relative + (abs(1 - (new_approximate_for_Y(arr[i,0], arr[i,1])/derivative_function_for_Y(arr[i,0],arr[i,1]))))
    relative = (relative * 100)/ amount_point
    return relative 


def relative_YY2():
  relative = 0
  relative1 = 0
  for j in range(amount_point):
    if (abs(new_approximate_for_Y(x[j],y[j]) <=1e-8 or abs(derivative_function_YY(x[j],y[j])) <=1e-8)):
      relative = relative + 0
    else:
      relative = relative + (derivative_function_YY(x[j],y[j]) - new_approximate_for_Y(x[j],y[j]))**2
    relative1 = relative1 + derivative_function_YY(x[j],y[j])**2
  relative = relative**0.5
  relative1 = relative1**0.5
  relative2 = relative/relative1
  relative2 = (100 * relative2)/amount_point
  return relative2 

def relative_YY3():
  lossanlim = []
  anlim1 = []
   
  for i in range(amount_point):
    anlim = np.array((derivative_function_YY(x[i],y[i]) - new_approximate_for_Y(x[j],y[j])))
    lossanlim = np.append(lossanlim, anlim)
    lim = np.array((derivative_function_YY(x[i],y[i])))
    anlim1 = np.append(anlim1, lim)
  max_element1 = max(lossanlim)
  max_der = max(anlim1)
  relative = (100*(max_element1/(max_der)))/amount_point
     
  return relative

# Commented out IPython magic to ensure Python compatibility.
import pylab
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.colors import LinearSegmentedColormap
from matplotlib import cm

# %matplotlib inline
step_grid_X = (domain_X[1] - domain_X[0])/amount_point
step_grid_Y = (domain_Y[1] - domain_Y[0])/amount_point
x = np.arange(domain_X[0], domain_X[1], step_grid_X)
y = np.arange(domain_Y[0], domain_Y[1], step_grid_Y)

x_print, y_print = np.meshgrid(x,y)

def grafic_derivative_for_X():
  fig = pylab.figure()
  axes = Axes3D(fig)
  
  z_print_app_X = (np.array([new_approximate_for_X(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)
  print('график производной по Х:')
  axes.plot_surface(x_print,y_print,( z_print_app_X), cmap  = cm.jet )
 
  pylab.show()

def grafic_derivative_for_Y():
  fig = pylab.figure()
  axes = Axes3D(fig)

  z_print_app_Y = (np.array([new_approximate_for_Y(x[i%amount_point],y[i//amount_point]) for i in range(amount_point**2)])).reshape(amount_point,-1)
  print('график производно по У:')
  axes.plot_surface(x_print,y_print,( z_print_app_Y), cmap  = cm.jet )

  pylab.show()

 
#взятие интеграла (обычным способом суммами)
def integral_output():
  amount_step_integral = 80
  step_integral_X = (domain_X[1] - domain_X[0])/amount_step_integral
  step_integral_Y = (domain_Y[1] - domain_Y[0])/amount_step_integral
  res_integral = 0
  res_integral_function = 0
  for i in range(amount_step_integral):
    for j in range(amount_step_integral):
      mean_approximate_function = (function(domain_X[0] + i * step_integral_X, domain_Y[0] + j * step_integral_Y) + function(domain_X[0] + (i+1) * step_integral_X, domain_Y[0] + j * step_integral_Y) + function(domain_X[0] + i * step_integral_X, domain_Y[0] + (j+1) * step_integral_Y) + function(domain_X[0] + (i+1) * step_integral_X, domain_Y[0] + (j+1) * step_integral_Y))/4
      size = step_integral_X * step_integral_Y * mean_approximate_function 
      res_integral_function = res_integral_function + size
      mean_approximate = (approximate(domain_X[0] + i * step_integral_X, domain_Y[0] + j * step_integral_Y) + approximate(domain_X[0] + (i+1) * step_integral_X, domain_Y[0] + j * step_integral_Y) + approximate(domain_X[0] + i * step_integral_X, domain_Y[0] + (j+1) * step_integral_Y) + approximate(domain_X[0] + (i+1) * step_integral_X, domain_Y[0] + (j+1) * step_integral_Y))/4
      size = step_integral_X * step_integral_Y * mean_approximate 
      res_integral = res_integral + size
  print('значение интеграла для апроксимации через центральные разницы по всем точкам из области:', res_integral)
  print('значение интеграла для функции через центральные разницы по всем точкам из области:', res_integral_function)
  print('')
# вычисление интеграла с помощью формул Гаусса:

  for ui in range(2):
    if ui == 0:
      method_integral = 1
    if ui == 1:
      method_integral = 2
    if method_integral==1:
      C_x = [-0.774596669, 0.0000, 0.774596669]
      w_x = [0.555555556,  0.888888889, 0.555555556]
      C_y = [-0.774596669, 0.0000, 0.774596669]
      w_y = [0.555555556,  0.888888889, 0.555555556]
    if method_integral==2:
      C_x = [-1, 0, 1]
      w_x = [1/3, 4/3, 1/3]
      C_y = [-1, 0, 1]
      w_y = [1/3, 4/3, 1/3]


    position_a_for_X = domain_X[0] - delta_X * amount_domain_in_element_X
    position_a_for_Y = domain_Y[0]
    position_b_for_Y = position_a_for_Y + delta_Y * amount_domain_in_element_Y
    e_Y = position_a_for_Y
    e_x = position_a_for_X
    good_integral_approximate = 0
    good_integral_function = 0
    result_approximate = 0
    result_function = 0
    for k in range(domain_elemant_1X * domain_elemant_1Y):
      position_a_for_X = position_a_for_X + delta_X * amount_domain_in_element_X
      position_b_for_X = position_a_for_X + delta_X * amount_domain_in_element_X
      position_a_for_X1 = round(position_a_for_X, 7)
      position_a_for_X2 = round(position_a_for_X)
      if abs(position_a_for_X2 - position_a_for_X1) <0.00001:
        position_a_for_X =position_a_for_X2
      if position_a_for_X >= domain_X[1]:
        position_a_for_X = domain_X[0]
        position_b_for_X = position_a_for_X + delta_X * amount_domain_in_element_X
        position_a_for_Y = position_a_for_Y + delta_Y * amount_domain_in_element_Y
        position_b_for_Y = position_a_for_Y + delta_Y * amount_domain_in_element_Y  
      position_a_for_X = round(position_a_for_X, 12)
      position_b_for_X = round(position_b_for_X, 12)
      position_a_for_Y = round(position_a_for_Y, 12)
      position_b_for_Y = round(position_b_for_Y, 12)
   
      for i in range(len(C_x)):
        for j in range(len(C_y)):
          result_approximate = result_approximate + w_x[i] * w_y[j] * approximate((position_a_for_X + position_b_for_X)/2 + ((position_b_for_X - position_a_for_X)/2) * C_x[i], (position_a_for_Y + position_b_for_Y)/2 + ((position_b_for_Y - position_a_for_Y)/2) * C_y[j])
          result_function = result_function + w_x[i] * w_y[j] * function((position_a_for_X + position_b_for_X)/2 + ((position_b_for_X - position_a_for_X)/2) * C_x[i], (position_a_for_Y + position_b_for_Y)/2 + ((position_b_for_Y - position_a_for_Y)/2) * C_y[j])
      good_integral_function = good_integral_function + result_function * (position_b_for_X - position_a_for_X)*(position_b_for_Y - position_a_for_Y)/4
      good_integral_approximate = good_integral_approximate + result_approximate * (position_b_for_X - position_a_for_X)*(position_b_for_Y - position_a_for_Y)/4
      result_approximate = 0
      result_function = 0
    if ui == 0: 
      print('значение интеграла для функции через формулу Гаусса:', good_integral_function)
      print('значение интеграла для апроксимации через формулу Гаусса:', good_integral_approximate)
      print('')
      fu1 = good_integral_function 
      app1 = good_integral_approximate
    if ui == 1:
      print('значение интеграла для функции через формулу Ньютона-Котиса:', good_integral_function)
      print('значение интеграла для апроксимации через формулу Ньютона-Котиса:', good_integral_approximate)
      print('')
      fu2 = good_integral_function 
      app2 = good_integral_approximate
  print('разность формулы Гаусса и формулы Ньтона-Котиса для функции:', fu1 - fu2)
  print('разность формулы Гаусса и формулы Ньтона-Котиса для апроксимации:', app1 - app2)
  print('')
  print('отклонение произволной для формулы Гаусса:',  res_integral_function - app1)
  print('отклонение произволной для формулы Ньютона-Котиса:',  res_integral_function - app2)
  print('')
  return ('завершение анализа')

